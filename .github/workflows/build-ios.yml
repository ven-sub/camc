name: Build iOS

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build (e.g., v1.0.0)'
        required: true
        type: string

jobs:
  build-ios:
    name: Build iOS
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        targets: aarch64-apple-ios,aarch64-apple-ios-sim
        
    - name: Cache Rust dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/bin/
          ~/.cargo/registry/index/
          ~/.cargo/registry/cache/
          ~/.cargo/git/db/
          src-tauri/target/
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-
          
    - name: Install dependencies
      run: npm ci
      
    - name: Install Tauri CLI
      run: npm install -g @tauri-apps/cli@next

    - name: Install Bundler and fastlane
      run: |
        gem install bundler
        bundle install
    
    - name: Install xcbeautify (optional, for cleaner output)
      run: |
        brew install xcbeautify || echo "xcbeautify not available, continuing without it"
      
    - name: Import iOS Code Signing Certificate
      env:
        IOS_CERTIFICATE_BASE64: ${{ secrets.IOS_CERTIFICATE_BASE64 }}
        IOS_CERTIFICATE_PASSWORD: ${{ secrets.IOS_CERTIFICATE_PASSWORD }}
      run: |
        echo "$IOS_CERTIFICATE_BASE64" | base64 --decode > /tmp/ios_certificate.p12
        security create-keychain -p "" build.keychain
        security default-keychain -s build.keychain
        security unlock-keychain -p "" build.keychain
        security import /tmp/ios_certificate.p12 -k ~/Library/Keychains/build.keychain -P "$IOS_CERTIFICATE_PASSWORD" -T /usr/bin/codesign
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain
        rm /tmp/ios_certificate.p12

    - name: Install iOS Provisioning Profile
      env:
        IOS_PROVISIONING_PROFILE_BASE64: ${{ secrets.IOS_PROVISIONING_PROFILE_BASE64 }}
      run: |
        mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
        echo "$IOS_PROVISIONING_PROFILE_BASE64" | base64 --decode > ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision
        PROFILE_DATA=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision)
        PROFILE_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<< "$PROFILE_DATA")
        DEVELOPMENT_TEAM=$(/usr/libexec/PlistBuddy -c 'Print :TeamIdentifier:0' /dev/stdin <<< "$PROFILE_DATA" || /usr/libexec/PlistBuddy -c 'Print :TeamIdentifier' /dev/stdin <<< "$PROFILE_DATA")
        mv ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/$PROFILE_UUID.mobileprovision
        echo "PROVISIONING_PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV
        echo "DEVELOPMENT_TEAM=$DEVELOPMENT_TEAM" >> $GITHUB_ENV
        echo "Installed provisioning profile: $PROFILE_UUID"
        echo "Development team: $DEVELOPMENT_TEAM"
      
    - name: Setup iOS project
      run: |
        # Initialize iOS project if it doesn't exist
        if [ ! -d "src-tauri/gen/apple" ]; then
          npx @tauri-apps/cli ios init
        else
          echo "iOS project already exists, skipping init"
        fi

    - name: Configure Xcode Project for Manual Signing
      run: |
        PROVISIONING_PROFILE_UUID="${{ env.PROVISIONING_PROFILE_UUID }}"
        DEVELOPMENT_TEAM="${{ env.DEVELOPMENT_TEAM }}"
        # Update Xcode project to use manual code signing
        XCODE_PROJECT="src-tauri/gen/apple/circuit-assistant-mobile-companion.xcodeproj"
        PROJECT_FILE="$XCODE_PROJECT/project.pbxproj"
        
        if [ ! -f "$PROJECT_FILE" ]; then
          echo "Project file not found, will be created by Tauri build"
          exit 0
        fi
        
        # Backup the project file
        cp "$PROJECT_FILE" "$PROJECT_FILE.backup"
        
        # Update code signing settings using sed (simpler and avoids YAML parsing issues)
        # Set CODE_SIGN_STYLE to Manual
        sed -i '' 's/CODE_SIGN_STYLE = Automatic;/CODE_SIGN_STYLE = Manual;/g' "$PROJECT_FILE"
        
        # Set CODE_SIGN_IDENTITY to Apple Distribution
        sed -i '' 's/CODE_SIGN_IDENTITY = "Apple Development";/CODE_SIGN_IDENTITY = "Apple Distribution";/g' "$PROJECT_FILE"
        sed -i '' 's/CODE_SIGN_IDENTITY = "";/CODE_SIGN_IDENTITY = "Apple Distribution";/g' "$PROJECT_FILE"
        
        # Set DEVELOPMENT_TEAM
        if grep -q "DEVELOPMENT_TEAM" "$PROJECT_FILE"; then
          sed -i '' "s/DEVELOPMENT_TEAM = .*/DEVELOPMENT_TEAM = $DEVELOPMENT_TEAM;/g" "$PROJECT_FILE"
        else
          # Add DEVELOPMENT_TEAM after CODE_SIGN_IDENTITY
          perl -i -pe "s/(CODE_SIGN_IDENTITY = \"Apple Distribution\";)/\$1\n\t\t\t\tDEVELOPMENT_TEAM = $DEVELOPMENT_TEAM;/" "$PROJECT_FILE"
        fi
        
        # Update or add PROVISIONING_PROFILE_SPECIFIER
        if grep -q "PROVISIONING_PROFILE_SPECIFIER" "$PROJECT_FILE"; then
          sed -i '' "s/PROVISIONING_PROFILE_SPECIFIER = .*/PROVISIONING_PROFILE_SPECIFIER = $PROVISIONING_PROFILE_UUID;/g" "$PROJECT_FILE"
        else
          # Add PROVISIONING_PROFILE_SPECIFIER after DEVELOPMENT_TEAM
          perl -i -pe "s/(DEVELOPMENT_TEAM = $DEVELOPMENT_TEAM;)/\$1\n\t\t\t\tPROVISIONING_PROFILE_SPECIFIER = $PROVISIONING_PROFILE_UUID;/" "$PROJECT_FILE"
        fi
        
        echo "Updated Xcode project for manual signing with profile: $PROVISIONING_PROFILE_UUID and team: $DEVELOPMENT_TEAM"
        
        # Modify the build script to skip Tauri CLI if library already exists
        # This prevents the dev server connection error in CI
        if grep -q "tauri ios xcode-script" "$PROJECT_FILE"; then
          # Create a wrapper script that checks if libapp.a exists before calling Tauri
          WRAPPER_DIR="$(dirname "$PROJECT_FILE")"
          WRAPPER_SCRIPT="$WRAPPER_DIR/build_rust_wrapper.sh"
          
          # Write the wrapper script using printf to avoid YAML parsing issues
          printf '#!/bin/bash\n' > "$WRAPPER_SCRIPT"
          printf '# Wrapper script that skips Tauri CLI if library is already built\n' >> "$WRAPPER_SCRIPT"
          printf 'PROJECT_DIR="$(dirname "${BASH_SOURCE[0]}")"\n' >> "$WRAPPER_SCRIPT"
          printf 'LIB_PATH_RELEASE="$PROJECT_DIR/Externals/arm64/Release/libapp.a"\n' >> "$WRAPPER_SCRIPT"
          printf 'LIB_PATH_DEBUG="$PROJECT_DIR/Externals/arm64/Debug/libapp.a"\n' >> "$WRAPPER_SCRIPT"
          printf 'if [ "${CONFIGURATION}" = "Release" ] && [ -f "$LIB_PATH_RELEASE" ]; then\n' >> "$WRAPPER_SCRIPT"
          printf '  echo "Pre-built Rust library found, skipping Tauri build script"\n' >> "$WRAPPER_SCRIPT"
          printf '  exit 0\n' >> "$WRAPPER_SCRIPT"
          printf 'elif [ "${CONFIGURATION}" = "Debug" ] && [ -f "$LIB_PATH_DEBUG" ]; then\n' >> "$WRAPPER_SCRIPT"
          printf '  echo "Pre-built Rust library found, skipping Tauri build script"\n' >> "$WRAPPER_SCRIPT"
          printf '  exit 0\n' >> "$WRAPPER_SCRIPT"
          printf 'fi\n' >> "$WRAPPER_SCRIPT"
          printf 'cd "$(dirname "$PROJECT_DIR")"\n' >> "$WRAPPER_SCRIPT"
          printf 'exec npm run -- tauri ios xcode-script "$@"\n' >> "$WRAPPER_SCRIPT"
          chmod +x "$WRAPPER_SCRIPT"
          
          # Update the project file to use the wrapper script
          # Escape the path for sed (use absolute path)
          ESCAPED_WRAPPER=$(echo "$WRAPPER_SCRIPT" | sed 's/\//\\\//g')
          sed -i '' "s|npm run -- tauri ios xcode-script|$ESCAPED_WRAPPER|g" "$PROJECT_FILE"
          echo "Updated build script to use wrapper that checks for pre-built library"
        fi
      
    - name: Build iOS IPA for TestFlight
      env:
        APPSTORE_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}
        APPSTORE_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
        APPSTORE_PRIVATE_KEY: ${{ secrets.APPSTORE_PRIVATE_KEY }}
        PROVISIONING_PROFILE_UUID: ${{ env.PROVISIONING_PROFILE_UUID }}
        DEVELOPMENT_TEAM: ${{ env.DEVELOPMENT_TEAM }}
      run: |
        # Build Rust library first and ensure it's in the expected location
        cd src-tauri
        cargo build --target aarch64-apple-ios --release
        
        # Find the actual library file (could have underscores or hyphens)
        LIB_FILE=$(find target/aarch64-apple-ios/release -name "lib*.a" -type f | head -n 1)
        if [ -z "$LIB_FILE" ]; then
          echo "Error: Could not find built Rust library in target/aarch64-apple-ios/release/"
          ls -la target/aarch64-apple-ios/release/ || echo "Directory does not exist"
          exit 1
        fi
        echo "Found Rust library: $LIB_FILE"
        
        # Ensure the library is in the location Tauri expects for Release builds
        mkdir -p gen/apple/Externals/arm64/Release
        cp "$LIB_FILE" gen/apple/Externals/arm64/Release/libapp.a
        echo "Copied library to gen/apple/Externals/arm64/Release/libapp.a"
        
        # Also copy to debug location to satisfy any debug checks during build
        mkdir -p gen/apple/Externals/arm64/Debug
        cp "$LIB_FILE" gen/apple/Externals/arm64/Debug/libapp.a
        echo "Copied library to gen/apple/Externals/arm64/Debug/libapp.a"
        
        cd ..
        
        # Create ExportOptions.plist for App Store distribution
        mkdir -p build
        cat > build/ExportOptions.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>method</key>
            <string>app-store</string>
            <key>destination</key>
            <string>upload</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>signingCertificate</key>
            <string>Apple Distribution</string>
            <key>provisioningProfiles</key>
            <dict>
                <key>org.circuitassistant.camc</key>
                <string>$PROVISIONING_PROFILE_UUID</string>
            </dict>
        </dict>
        </plist>
        EOF
        
        # Find the generated Xcode project
        XCODE_PROJECT="src-tauri/gen/apple/circuit-assistant-mobile-companion.xcodeproj"
        SCHEME="circuit-assistant-mobile-companion_iOS"
        ARCHIVE_PATH="$PWD/build/ios.xcarchive"
        EXPORT_PATH="$PWD/build/ios-export"
        
        # The Rust library is already built above and copied to the expected location
        # Skip the build step and go straight to archive, which will build if needed
        # The archive command will build the app, but we've pre-built the Rust code
        echo "Pre-built Rust library is ready, proceeding to archive step..."
        
        # Archive the app - this will build everything including the Rust code
        # But since we've pre-built the Rust library, the build script should find it
        echo "Archiving iOS app (this will build if needed)..."
        
        # Set environment variables to prevent Tauri dev server connection
        export TAURI_SKIP_DEV_SERVER=1
        export CI=true
        export RELEASE_BUILD=true
        
        set -o pipefail
        if ! xcodebuild archive \
          -project "$XCODE_PROJECT" \
          -scheme "$SCHEME" \
          -configuration Release \
          -archivePath "$ARCHIVE_PATH" \
          CODE_SIGN_STYLE=Manual \
          CODE_SIGN_IDENTITY="Apple Distribution" \
          PROVISIONING_PROFILE_SPECIFIER="$PROVISIONING_PROFILE_UUID" \
          DEVELOPMENT_TEAM="$DEVELOPMENT_TEAM" \
          2>&1 | tee /tmp/xcodebuild-archive.log | xcbeautify; then
          echo "Archive failed. Full output:"
          cat /tmp/xcodebuild-archive.log
          exit 1
        fi
        
        # Verify archive was created
        if [ ! -d "$ARCHIVE_PATH" ]; then
          echo "Error: Archive was not created at $ARCHIVE_PATH"
          exit 1
        fi
        echo "Archive created successfully at $ARCHIVE_PATH"
        
        # Export IPA for App Store
        xcodebuild -exportArchive \
          -archivePath "$ARCHIVE_PATH" \
          -exportPath "$EXPORT_PATH" \
          -exportOptionsPlist build/ExportOptions.plist \
          | xcbeautify || cat
        
        # Find the IPA
        IPA_FILE=$(find "$EXPORT_PATH" -name "*.ipa" | head -n 1)
        if [ -z "$IPA_FILE" ]; then
          echo "Error: IPA file not found in $EXPORT_PATH"
          ls -la "$EXPORT_PATH" || echo "Export path does not exist"
          exit 1
        fi
        echo "IPA_PATH=$IPA_FILE" >> $GITHUB_ENV
        echo "Built IPA: $IPA_FILE"
      
    - name: Upload to TestFlight
      env:
        APPSTORE_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}
        APPSTORE_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
        APPSTORE_PRIVATE_KEY: ${{ secrets.APPSTORE_PRIVATE_KEY }}
      run: |
        bundle exec fastlane ios testflight ipa:"$IPA_PATH"
      
    - name: Upload iOS build artifact
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: camc-ios-${{ github.ref_name }}
        path: |
          src-tauri/gen/ios/build/
          build/*.ipa
