name: Build iOS

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build (e.g., v1.0.0)'
        required: true
        type: string

jobs:
  build-ios:
    name: Build iOS
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        targets: aarch64-apple-ios,aarch64-apple-ios-sim
        
    - name: Cache Rust dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/bin/
          ~/.cargo/registry/index/
          ~/.cargo/registry/cache/
          ~/.cargo/git/db/
          src-tauri/target/
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-
    
    - name: Cache iOS project and built libraries
      uses: actions/cache@v4
      with:
        path: |
          src-tauri/gen/apple/
          src-tauri/gen/ios/
        key: ${{ runner.os }}-ios-project-${{ hashFiles('src-tauri/tauri.conf.json', 'src-tauri/Cargo.toml', 'package.json') }}
        restore-keys: |
          ${{ runner.os }}-ios-project-
          
    - name: Install dependencies
      run: npm ci
      
    - name: Install Tauri CLI
      run: npm install -g @tauri-apps/cli@next

    - name: Install Bundler and fastlane
      run: |
        gem install bundler
        bundle install
    
    - name: Install xcbeautify (optional, for cleaner output)
      run: |
        brew install xcbeautify || echo "xcbeautify not available, continuing without it"
      
    - name: Import iOS Code Signing Certificate
      env:
        IOS_CERTIFICATE_BASE64: ${{ secrets.IOS_CERTIFICATE_BASE64 }}
        IOS_CERTIFICATE_PASSWORD: ${{ secrets.IOS_CERTIFICATE_PASSWORD }}
      run: |
        echo "$IOS_CERTIFICATE_BASE64" | base64 --decode > /tmp/ios_certificate.p12
        security create-keychain -p "" build.keychain
        security default-keychain -s build.keychain
        security unlock-keychain -p "" build.keychain
        security import /tmp/ios_certificate.p12 -k ~/Library/Keychains/build.keychain -P "$IOS_CERTIFICATE_PASSWORD" -T /usr/bin/codesign
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain
        rm /tmp/ios_certificate.p12

    - name: Install iOS Provisioning Profile
      env:
        IOS_PROVISIONING_PROFILE_BASE64: ${{ secrets.IOS_PROVISIONING_PROFILE_BASE64 }}
      run: |
        mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
        echo "$IOS_PROVISIONING_PROFILE_BASE64" | base64 --decode > ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision
        PROFILE_DATA=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision)
        PROFILE_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<< "$PROFILE_DATA")
        DEVELOPMENT_TEAM=$(/usr/libexec/PlistBuddy -c 'Print :TeamIdentifier:0' /dev/stdin <<< "$PROFILE_DATA" || /usr/libexec/PlistBuddy -c 'Print :TeamIdentifier' /dev/stdin <<< "$PROFILE_DATA")
        mv ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/$PROFILE_UUID.mobileprovision
        echo "PROVISIONING_PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV
        echo "DEVELOPMENT_TEAM=$DEVELOPMENT_TEAM" >> $GITHUB_ENV
        echo "Installed provisioning profile: $PROFILE_UUID"
        echo "Development team: $DEVELOPMENT_TEAM"
      
    - name: Setup iOS project
      run: |
        # Initialize iOS project if it doesn't exist
        if [ ! -d "src-tauri/gen/apple" ]; then
          npx @tauri-apps/cli ios init
        else
          echo "iOS project already exists, skipping init"
        fi

    - name: Configure Xcode Project for Manual Signing
      run: |
        PROVISIONING_PROFILE_UUID="${{ env.PROVISIONING_PROFILE_UUID }}"
        DEVELOPMENT_TEAM="${{ env.DEVELOPMENT_TEAM }}"
        # Update Xcode project to use manual code signing
        XCODE_PROJECT="src-tauri/gen/apple/circuit-assistant-mobile-companion.xcodeproj"
        PROJECT_FILE="$XCODE_PROJECT/project.pbxproj"
        
        if [ ! -f "$PROJECT_FILE" ]; then
          echo "Project file not found, will be created by Tauri build"
          exit 0
        fi
        
        # Backup the project file
        cp "$PROJECT_FILE" "$PROJECT_FILE.backup"
        
        # Update code signing settings using sed (simpler and avoids YAML parsing issues)
        # Set CODE_SIGN_STYLE to Manual
        sed -i '' 's/CODE_SIGN_STYLE = Automatic;/CODE_SIGN_STYLE = Manual;/g' "$PROJECT_FILE"
        
        # Set CODE_SIGN_IDENTITY to Apple Distribution
        sed -i '' 's/CODE_SIGN_IDENTITY = "Apple Development";/CODE_SIGN_IDENTITY = "Apple Distribution";/g' "$PROJECT_FILE"
        sed -i '' 's/CODE_SIGN_IDENTITY = "";/CODE_SIGN_IDENTITY = "Apple Distribution";/g' "$PROJECT_FILE"
        
        # Set DEVELOPMENT_TEAM
        if grep -q "DEVELOPMENT_TEAM" "$PROJECT_FILE"; then
          sed -i '' "s/DEVELOPMENT_TEAM = .*/DEVELOPMENT_TEAM = $DEVELOPMENT_TEAM;/g" "$PROJECT_FILE"
        else
          # Add DEVELOPMENT_TEAM after CODE_SIGN_IDENTITY
          perl -i -pe "s/(CODE_SIGN_IDENTITY = \"Apple Distribution\";)/\$1\n\t\t\t\tDEVELOPMENT_TEAM = $DEVELOPMENT_TEAM;/" "$PROJECT_FILE"
        fi
        
        # Update or add PROVISIONING_PROFILE_SPECIFIER
        if grep -q "PROVISIONING_PROFILE_SPECIFIER" "$PROJECT_FILE"; then
          sed -i '' "s/PROVISIONING_PROFILE_SPECIFIER = .*/PROVISIONING_PROFILE_SPECIFIER = $PROVISIONING_PROFILE_UUID;/g" "$PROJECT_FILE"
        else
          # Add PROVISIONING_PROFILE_SPECIFIER after DEVELOPMENT_TEAM
          perl -i -pe "s/(DEVELOPMENT_TEAM = $DEVELOPMENT_TEAM;)/\$1\n\t\t\t\tPROVISIONING_PROFILE_SPECIFIER = $PROVISIONING_PROFILE_UUID;/" "$PROJECT_FILE"
        fi
        
        # Force Release configuration for Archive builds
        # Set CONFIGURATION build setting to Release if not already set
        if ! grep -q "CONFIGURATION.*Release" "$PROJECT_FILE" || ! grep -q "Release.*CONFIGURATION" "$PROJECT_FILE"; then
          # Try to add CONFIGURATION = Release to build settings
          perl -i -pe "s/(CODE_SIGN_STYLE = Manual;)/\$1\n\t\t\t\tCONFIGURATION = Release;/" "$PROJECT_FILE" || echo "Note: Could not set CONFIGURATION in project file"
        fi
        
        echo "Updated Xcode project for manual signing with profile: $PROVISIONING_PROFILE_UUID and team: $DEVELOPMENT_TEAM"
        
        # Modify the build script to set environment variables for CI
        # We need Tauri build to run to generate iOS FFI exports (_start_app symbol)
        # But we set env vars to prevent dev server connection issues
        if grep -q "tauri ios xcode-script" "$PROJECT_FILE"; then
          # Create a wrapper script that sets CI environment variables before calling Tauri
          # ${SRCROOT} points to the directory containing the .xcodeproj (src-tauri/gen/apple/)
          # So we need to place the wrapper script there, not inside the .xcodeproj directory
          WRAPPER_DIR="$(dirname "$(dirname "$PROJECT_FILE")")"
          WRAPPER_SCRIPT="$WRAPPER_DIR/build_rust_wrapper.sh"
          
          # Write the wrapper script using printf to avoid YAML parsing issues
          printf '#!/bin/bash\n' > "$WRAPPER_SCRIPT"
          printf '# Wrapper script to set CI environment variables for Tauri build\n' >> "$WRAPPER_SCRIPT"
          printf '# Output to stderr so it shows up in Xcode build output\n' >> "$WRAPPER_SCRIPT"
          printf '# Use set -e but with explicit error handling\n' >> "$WRAPPER_SCRIPT"
          printf 'set -e\n' >> "$WRAPPER_SCRIPT"
          printf 'set -x\n' >> "$WRAPPER_SCRIPT"
          printf 'exec >&2\n' >> "$WRAPPER_SCRIPT"
          printf 'echo "=== Wrapper Script Started === $(date)"\n' >> "$WRAPPER_SCRIPT"
          printf 'echo "Script location: ${BASH_SOURCE[0]}"\n' >> "$WRAPPER_SCRIPT"
          printf 'echo "SRCROOT=${SRCROOT}"\n' >> "$WRAPPER_SCRIPT"
          printf 'echo "CONFIGURATION=${CONFIGURATION}"\n' >> "$WRAPPER_SCRIPT"
          printf 'echo "PWD=$(pwd)"\n' >> "$WRAPPER_SCRIPT"
          printf '\n' >> "$WRAPPER_SCRIPT"
          printf '# Set environment variables to prevent dev server connection in CI\n' >> "$WRAPPER_SCRIPT"
          printf 'export TAURI_SKIP_DEV_SERVER=1\n' >> "$WRAPPER_SCRIPT"
          printf 'export CI=true\n' >> "$WRAPPER_SCRIPT"
          printf 'export RELEASE_BUILD=true\n' >> "$WRAPPER_SCRIPT"
          printf '\n' >> "$WRAPPER_SCRIPT"
          printf '# Create empty dev server addr file to prevent Tauri CLI panic\n' >> "$WRAPPER_SCRIPT"
          printf '# Tauri CLI unconditionally tries to read this file and panics if missing\n' >> "$WRAPPER_SCRIPT"
          printf '# We create an empty file - Tauri will fail to parse it and skip dev server\n' >> "$WRAPPER_SCRIPT"
          printf 'SERVER_ADDR_FILE="${TMPDIR:-/tmp}/org.circuitassistant.camc-server-addr"\n' >> "$WRAPPER_SCRIPT"
          printf 'echo "Ensuring dev server addr file exists (empty to skip connection): $SERVER_ADDR_FILE"\n' >> "$WRAPPER_SCRIPT"
          printf 'mkdir -p "$(dirname "$SERVER_ADDR_FILE")" || { echo "ERROR: Failed to create directory for server addr file"; exit 1; }\n' >> "$WRAPPER_SCRIPT"
          printf '# Create empty file - Tauri will fail to parse and skip dev server connection\n' >> "$WRAPPER_SCRIPT"
          printf 'touch "$SERVER_ADDR_FILE" || { echo "ERROR: Failed to create server addr file"; exit 1; }\n' >> "$WRAPPER_SCRIPT"
          printf 'echo "Created empty dev server addr file (prevents panic, skips connection)"\n' >> "$WRAPPER_SCRIPT"
          printf '\n' >> "$WRAPPER_SCRIPT"
          printf '# Get absolute path to the project root (where package.json is)\n' >> "$WRAPPER_SCRIPT"
          printf 'SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"\n' >> "$WRAPPER_SCRIPT"
          printf 'PROJECT_ROOT="$(cd "$SCRIPT_DIR/../../.." && pwd)"\n' >> "$WRAPPER_SCRIPT"
          printf 'echo "Project root: $PROJECT_ROOT"\n' >> "$WRAPPER_SCRIPT"
          printf 'echo "Checking if project root exists..."\n' >> "$WRAPPER_SCRIPT"
          printf 'if [ ! -d "$PROJECT_ROOT" ]; then\n' >> "$WRAPPER_SCRIPT"
          printf '  echo "ERROR: Project root does not exist: $PROJECT_ROOT"\n' >> "$WRAPPER_SCRIPT"
          printf '  exit 1\n' >> "$WRAPPER_SCRIPT"
          printf 'fi\n' >> "$WRAPPER_SCRIPT"
          printf '\n' >> "$WRAPPER_SCRIPT"
          printf '# Always run Tauri build to ensure iOS FFI exports are generated\n' >> "$WRAPPER_SCRIPT"
          printf 'echo "=== Running Tauri build to generate iOS FFI exports ==="\n' >> "$WRAPPER_SCRIPT"
          printf 'cd "$PROJECT_ROOT" || { echo "ERROR: Failed to cd to $PROJECT_ROOT"; exit 1; }\n' >> "$WRAPPER_SCRIPT"
          printf 'echo "Current directory: $(pwd)"\n' >> "$WRAPPER_SCRIPT"
          printf 'echo "Running: npm run -- tauri ios xcode-script $*"\n' >> "$WRAPPER_SCRIPT"
          printf 'exec npm run -- tauri ios xcode-script "$@"\n' >> "$WRAPPER_SCRIPT"
          
          chmod +x "$WRAPPER_SCRIPT"
          
          # Verify the script was created and is executable
          if [ ! -f "$WRAPPER_SCRIPT" ]; then
            echo "ERROR: Wrapper script was not created at $WRAPPER_SCRIPT"
            exit 1
          fi
          if [ ! -x "$WRAPPER_SCRIPT" ]; then
            echo "ERROR: Wrapper script is not executable"
            exit 1
          fi
          echo "✓ Verified: Wrapper script created at $WRAPPER_SCRIPT"
          echo "Script size: $(wc -l < "$WRAPPER_SCRIPT") lines"
          
          # Update the project file to use the wrapper script
          # Use ${SRCROOT} which Xcode provides - it points to the directory containing the .xcodeproj
          # This avoids path resolution issues when Xcode runs from DerivedData
          # Replace the npm command with the wrapper script path
          # ${SRCROOT} is an Xcode variable that points to the directory containing the .xcodeproj
          # In bash double quotes, \${SRCROOT} becomes ${SRCROOT} which is what we want in the file
          # Need to match the full shellScript line pattern in project.pbxproj
          # Pattern: shellScript = "npm run -- tauri ios xcode-script [args...]";
          # Replace with: shellScript = "${SRCROOT}/build_rust_wrapper.sh [args...]";
          # Use a more specific pattern that captures everything after the npm command
          if grep -q "npm run -- tauri ios xcode-script" "$PROJECT_FILE"; then
            # Use perl for more reliable multiline/pattern matching
            perl -i -pe 's|(shellScript = ")npm run -- tauri ios xcode-script |$1\${SRCROOT}/build_rust_wrapper.sh |g' "$PROJECT_FILE"
            echo "Updated build script using perl replacement"
          else
            echo "Note: npm command not found in project file (may have been already replaced)"
          fi
          echo "Updated build script to use wrapper at: \${SRCROOT}/build_rust_wrapper.sh"
          
          # Verify the replacement worked
          if grep -q "\${SRCROOT}/build_rust_wrapper.sh" "$PROJECT_FILE"; then
            echo "✓ Verified: Project file contains wrapper script path"
            # Show the actual line to verify it looks correct
            echo "Script line in project file:"
            grep "\${SRCROOT}/build_rust_wrapper.sh" "$PROJECT_FILE" | head -1
          else
            echo "⚠ Warning: Project file replacement might have failed"
            echo "Checking for remaining npm command references:"
            if grep -n "tauri ios xcode-script" "$PROJECT_FILE"; then
              echo "ERROR: npm command still found in project file - sed replacement failed!"
              exit 1
            else
              echo "No npm command found (replacement may have worked with different pattern)"
            fi
          fi
        fi
      
    - name: Build iOS IPA for TestFlight
      env:
        APPSTORE_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}
        APPSTORE_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
        APPSTORE_PRIVATE_KEY: ${{ secrets.APPSTORE_PRIVATE_KEY }}
        PROVISIONING_PROFILE_UUID: ${{ env.PROVISIONING_PROFILE_UUID }}
        DEVELOPMENT_TEAM: ${{ env.DEVELOPMENT_TEAM }}
      run: |
        # Ensure assets directory exists (Xcode project expects it)
        mkdir -p src-tauri/gen/apple/assets
        echo "Ensured assets directory exists"
        
        # Re-apply wrapper script modification to project file
        # Tauri might regenerate the project file, so we need to ensure our changes are in place
        XCODE_PROJECT="src-tauri/gen/apple/circuit-assistant-mobile-companion.xcodeproj"
        PROJECT_FILE="$XCODE_PROJECT/project.pbxproj"
        WRAPPER_SCRIPT="src-tauri/gen/apple/build_rust_wrapper.sh"
        
        if [ -f "$PROJECT_FILE" ] && [ -f "$WRAPPER_SCRIPT" ]; then
          echo "Re-applying wrapper script modification to project file..."
          if grep -q "npm run -- tauri ios xcode-script" "$PROJECT_FILE"; then
            perl -i -pe 's|(shellScript = ")npm run -- tauri ios xcode-script |$1\${SRCROOT}/build_rust_wrapper.sh |g' "$PROJECT_FILE"
            echo "✓ Re-applied wrapper script to project file"
          else
            echo "✓ Project file already uses wrapper script"
          fi
          
          # Verify one more time
          if grep -q "\${SRCROOT}/build_rust_wrapper.sh" "$PROJECT_FILE"; then
            echo "✓ Final verification: Project file contains wrapper script"
          else
            echo "⚠ WARNING: Project file does not contain wrapper script path!"
            echo "This may cause the build to fail. Showing project file line:"
            grep -n "shellScript" "$PROJECT_FILE" | head -1 || echo "No shellScript found"
          fi
        else
          echo "⚠ Warning: Project file or wrapper script not found, skipping re-application"
        fi
        
        # Note: We no longer pre-build Rust libraries here
        # Tauri build will run during Xcode archive phase (via wrapper script)
        # This ensures iOS FFI exports (_start_app symbol) are generated correctly
        # The wrapper script sets CI environment variables to prevent dev server issues
        # Caching handles Rust dependencies and iOS project files for faster rebuilds
        
        # Create ExportOptions.plist for App Store distribution
        mkdir -p build
        cat > build/ExportOptions.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>method</key>
            <string>app-store</string>
            <key>destination</key>
            <string>upload</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>signingCertificate</key>
            <string>Apple Distribution</string>
            <key>provisioningProfiles</key>
            <dict>
                <key>org.circuitassistant.camc</key>
                <string>$PROVISIONING_PROFILE_UUID</string>
            </dict>
        </dict>
        </plist>
        EOF
        
        # Find the generated Xcode project
        XCODE_PROJECT="src-tauri/gen/apple/circuit-assistant-mobile-companion.xcodeproj"
        SCHEME="circuit-assistant-mobile-companion_iOS"
        ARCHIVE_PATH="$PWD/build/ios.xcarchive"
        EXPORT_PATH="$PWD/build/ios-export"
        
        # The Rust library is already built above and copied to the expected location
        # Skip the build step and go straight to archive, which will build if needed
        # The archive command will build the app, but we've pre-built the Rust code
        echo "Pre-built Rust library is ready, proceeding to archive step..."
        
        # Archive the app - this will build everything including the Rust code
        # But since we've pre-built the Rust library, the build script should find it
        echo "Archiving iOS app (this will build if needed)..."
        
        # Set environment variables to prevent Tauri dev server connection
        export TAURI_SKIP_DEV_SERVER=1
        export CI=true
        export RELEASE_BUILD=true
        
        set -o pipefail
        if ! xcodebuild archive \
          -project "$XCODE_PROJECT" \
          -scheme "$SCHEME" \
          -configuration Release \
          -destination "generic/platform=iOS" \
          -archivePath "$ARCHIVE_PATH" \
          CODE_SIGN_STYLE=Manual \
          CODE_SIGN_IDENTITY="Apple Distribution" \
          PROVISIONING_PROFILE_SPECIFIER="$PROVISIONING_PROFILE_UUID" \
          DEVELOPMENT_TEAM="$DEVELOPMENT_TEAM" \
          2>&1 | tee /tmp/xcodebuild-archive.log | xcbeautify; then
          echo "Archive failed. Full output:"
          cat /tmp/xcodebuild-archive.log
          exit 1
        fi
        
        # Verify archive was created
        if [ ! -d "$ARCHIVE_PATH" ]; then
          echo "Error: Archive was not created at $ARCHIVE_PATH"
          exit 1
        fi
        echo "Archive created successfully at $ARCHIVE_PATH"
        
        # Export IPA for App Store
        xcodebuild -exportArchive \
          -archivePath "$ARCHIVE_PATH" \
          -exportPath "$EXPORT_PATH" \
          -exportOptionsPlist build/ExportOptions.plist \
          | xcbeautify || cat
        
        # Find the IPA
        IPA_FILE=$(find "$EXPORT_PATH" -name "*.ipa" | head -n 1)
        if [ -z "$IPA_FILE" ]; then
          echo "Error: IPA file not found in $EXPORT_PATH"
          ls -la "$EXPORT_PATH" || echo "Export path does not exist"
          exit 1
        fi
        echo "IPA_PATH=$IPA_FILE" >> $GITHUB_ENV
        echo "Built IPA: $IPA_FILE"
      
    - name: Upload to TestFlight
      env:
        APPSTORE_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}
        APPSTORE_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
        APPSTORE_PRIVATE_KEY: ${{ secrets.APPSTORE_PRIVATE_KEY }}
      run: |
        bundle exec fastlane ios testflight ipa:"$IPA_PATH"
      
    - name: Upload iOS build artifact
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: camc-ios-${{ github.ref_name }}
        path: |
          src-tauri/gen/ios/build/
          build/*.ipa
