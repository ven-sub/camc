name: Build iOS

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build (e.g., v1.0.0)'
        required: true
        type: string

jobs:
  build-ios:
    name: Build iOS
    runs-on: macos-latest
    timeout-minutes: 20
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install rustup fallback
      run: |
        if ! command -v rustup >/dev/null; then
          curl --proto '=https' --tlsv1.2 --retry 10 --retry-connrefused --location --silent --show-error --fail https://sh.rustup.rs | sh -s -- --default-toolchain none -y
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
        fi
    
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable
        targets: aarch64-apple-ios,aarch64-apple-ios-sim
    
    - name: Verify Rust
      run: |
        rustc --version
        cargo --version
        
    - name: Cache Rust dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/bin/
          ~/.cargo/registry/index/
          ~/.cargo/registry/cache/
          ~/.cargo/git/db/
          src-tauri/target/
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-
    
    - name: Cache iOS project and built libraries
      uses: actions/cache@v4
      with:
        path: |
          src-tauri/gen/apple/
          src-tauri/gen/ios/
        key: ${{ runner.os }}-ios-project-${{ hashFiles('src-tauri/tauri.conf.json', 'src-tauri/Cargo.toml', 'package.json') }}
        restore-keys: |
          ${{ runner.os }}-ios-project-
          
    - name: Install dependencies
      run: npm ci
      
    - name: Install Tauri CLI
      run: npm install -g @tauri-apps/cli@next

    - name: Install Bundler and fastlane
      run: |
        gem install bundler
        bundle install
    
    - name: Install xcbeautify (optional, for cleaner output)
      run: |
        brew install xcbeautify || echo "xcbeautify not available, continuing without it"
      
    - name: Import iOS Code Signing Certificate
      env:
        IOS_CERTIFICATE_BASE64: ${{ secrets.IOS_CERTIFICATE_BASE64 }}
        IOS_CERTIFICATE_PASSWORD: ${{ secrets.IOS_CERTIFICATE_PASSWORD }}
      run: |
        echo "$IOS_CERTIFICATE_BASE64" | base64 --decode > /tmp/ios_certificate.p12
        security create-keychain -p "" build.keychain
        security default-keychain -s build.keychain
        security unlock-keychain -p "" build.keychain
        # Set keychain timeout to 10 minutes (600 seconds) to prevent auto-lock during build
        security set-keychain-settings -t 600 -l ~/Library/Keychains/build.keychain
        security import /tmp/ios_certificate.p12 -k ~/Library/Keychains/build.keychain -P "$IOS_CERTIFICATE_PASSWORD" -T /usr/bin/codesign
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain
        rm /tmp/ios_certificate.p12

    - name: Install iOS Provisioning Profile
      env:
        IOS_PROVISIONING_PROFILE_BASE64: ${{ secrets.IOS_PROVISIONING_PROFILE_BASE64 }}
      run: |
        mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
        echo "$IOS_PROVISIONING_PROFILE_BASE64" | base64 --decode > ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision
        PROFILE_DATA=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision)
        PROFILE_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<< "$PROFILE_DATA")
        DEVELOPMENT_TEAM=$(/usr/libexec/PlistBuddy -c 'Print :TeamIdentifier:0' /dev/stdin <<< "$PROFILE_DATA" || /usr/libexec/PlistBuddy -c 'Print :TeamIdentifier' /dev/stdin <<< "$PROFILE_DATA")
        mv ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/$PROFILE_UUID.mobileprovision
        echo "PROVISIONING_PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV
        echo "DEVELOPMENT_TEAM=$DEVELOPMENT_TEAM" >> $GITHUB_ENV
        echo "Installed provisioning profile: $PROFILE_UUID"
        echo "Development team: $DEVELOPMENT_TEAM"
      
    - name: Build Frontend
      run: |
        # Build frontend with Vite (CRITICAL - app needs bundled assets)
        echo "Building frontend..."
        npm run build
        
        # Verify dist folder exists and has content
        if [ ! -d "dist" ] || [ -z "$(ls -A dist 2>/dev/null)" ]; then
          echo "Error: Frontend build failed or dist/ is empty"
          echo "The app will try to connect to dev server (localhost:1421) and fail"
          exit 1
        fi
        
        echo "✓ Frontend built successfully"
        echo "dist/ contents:"
        ls -lh dist/ | head -10
    
    - name: Setup iOS project
      run: |
        # Initialize iOS project if it doesn't exist
        if [ ! -d "src-tauri/gen/apple" ]; then
          npx @tauri-apps/cli ios init
        else
          echo "iOS project already exists, skipping init"
        fi
        
        # Ensure export compliance key is in Info.plist (fixes "Missing Compliance" in TestFlight)
        # Note: Build number will be updated just before archiving
        INFO_PLIST="src-tauri/gen/apple/circuit-assistant-mobile-companion_iOS/Info.plist"
        if [ -f "$INFO_PLIST" ]; then
          if ! grep -q "ITSAppUsesNonExemptEncryption" "$INFO_PLIST"; then
            echo "Adding export compliance key to Info.plist..."
            # Add the key before the closing </dict> tag
            perl -i -pe 's|</dict>\s*</plist>|\t<key>ITSAppUsesNonExemptEncryption</key>\n\t<false/>\n</dict>\n</plist>|' "$INFO_PLIST"
            echo "✓ Export compliance key added"
          else
            echo "✓ Export compliance key already present"
          fi
        fi

    - name: Configure Xcode Project for Manual Signing
      run: |
        PROVISIONING_PROFILE_UUID="${{ env.PROVISIONING_PROFILE_UUID }}"
        DEVELOPMENT_TEAM="${{ env.DEVELOPMENT_TEAM }}"
        # Update Xcode project to use manual code signing
        XCODE_PROJECT="src-tauri/gen/apple/circuit-assistant-mobile-companion.xcodeproj"
        PROJECT_FILE="$XCODE_PROJECT/project.pbxproj"
        
        if [ ! -f "$PROJECT_FILE" ]; then
          echo "Project file not found, will be created by Tauri build"
          exit 0
        fi
        
        # Backup the project file
        cp "$PROJECT_FILE" "$PROJECT_FILE.backup"
        
        # Update code signing settings using sed (simpler and avoids YAML parsing issues)
        # Set CODE_SIGN_STYLE to Manual
        sed -i '' 's/CODE_SIGN_STYLE = Automatic;/CODE_SIGN_STYLE = Manual;/g' "$PROJECT_FILE"
        
        # Set CODE_SIGN_IDENTITY to Apple Distribution
        sed -i '' 's/CODE_SIGN_IDENTITY = "Apple Development";/CODE_SIGN_IDENTITY = "Apple Distribution";/g' "$PROJECT_FILE"
        sed -i '' 's/CODE_SIGN_IDENTITY = "";/CODE_SIGN_IDENTITY = "Apple Distribution";/g' "$PROJECT_FILE"
        
        # Set DEVELOPMENT_TEAM
        if grep -q "DEVELOPMENT_TEAM" "$PROJECT_FILE"; then
          sed -i '' "s/DEVELOPMENT_TEAM = .*/DEVELOPMENT_TEAM = $DEVELOPMENT_TEAM;/g" "$PROJECT_FILE"
        else
          # Add DEVELOPMENT_TEAM after CODE_SIGN_IDENTITY
          perl -i -pe "s/(CODE_SIGN_IDENTITY = \"Apple Distribution\";)/\$1\n\t\t\t\tDEVELOPMENT_TEAM = $DEVELOPMENT_TEAM;/" "$PROJECT_FILE"
        fi
        
        # Update or add PROVISIONING_PROFILE_SPECIFIER
        if grep -q "PROVISIONING_PROFILE_SPECIFIER" "$PROJECT_FILE"; then
          sed -i '' "s/PROVISIONING_PROFILE_SPECIFIER = .*/PROVISIONING_PROFILE_SPECIFIER = $PROVISIONING_PROFILE_UUID;/g" "$PROJECT_FILE"
        else
          # Add PROVISIONING_PROFILE_SPECIFIER after DEVELOPMENT_TEAM
          perl -i -pe "s/(DEVELOPMENT_TEAM = $DEVELOPMENT_TEAM;)/\$1\n\t\t\t\tPROVISIONING_PROFILE_SPECIFIER = $PROVISIONING_PROFILE_UUID;/" "$PROJECT_FILE"
        fi
        
        # Force Release configuration for Archive builds
        # Set CONFIGURATION build setting to Release if not already set
        if ! grep -q "CONFIGURATION.*Release" "$PROJECT_FILE" || ! grep -q "Release.*CONFIGURATION" "$PROJECT_FILE"; then
          # Try to add CONFIGURATION = Release to build settings
          perl -i -pe "s/(CODE_SIGN_STYLE = Manual;)/\$1\n\t\t\t\tCONFIGURATION = Release;/" "$PROJECT_FILE" || echo "Note: Could not set CONFIGURATION in project file"
        fi
        
        echo "Updated Xcode project for manual signing with profile: $PROVISIONING_PROFILE_UUID and team: $DEVELOPMENT_TEAM"
        
        # Modify the build script to set environment variables for CI
        # We need Tauri build to run to generate iOS FFI exports (_start_app symbol)
        # But we set env vars to prevent dev server connection issues
        if grep -q "tauri ios xcode-script" "$PROJECT_FILE"; then
          # Create a wrapper script that sets CI environment variables before calling Tauri
          # ${SRCROOT} points to the directory containing the .xcodeproj (src-tauri/gen/apple/)
          # So we need to place the wrapper script there, not inside the .xcodeproj directory
          WRAPPER_DIR="$(dirname "$(dirname "$PROJECT_FILE")")"
          WRAPPER_SCRIPT="$WRAPPER_DIR/build_rust_wrapper.sh"
          
          # Create wrapper script using external script to avoid GitHub Actions expression length limits
          bash "$GITHUB_WORKSPACE/.github/scripts/create-wrapper-script.sh" "$WRAPPER_SCRIPT"
          
          # Verify the script was created and is executable
          if [ ! -f "$WRAPPER_SCRIPT" ]; then
            echo "ERROR: Wrapper script was not created at $WRAPPER_SCRIPT"
            exit 1
          fi
          if [ ! -x "$WRAPPER_SCRIPT" ]; then
            echo "ERROR: Wrapper script is not executable"
            exit 1
          fi
          echo "✓ Verified: Wrapper script created at $WRAPPER_SCRIPT"
          echo "Script size: $(wc -l < "$WRAPPER_SCRIPT") lines"
          echo "=== Wrapper script contents (first 200 lines) ==="
          sed -n '1,200p' "$WRAPPER_SCRIPT" || true
          echo "=== End wrapper script preview ==="
          
          # Update the project file to use the wrapper script
          # Use ${SRCROOT} which Xcode provides - it points to the directory containing the .xcodeproj
          # This avoids path resolution issues when Xcode runs from DerivedData
          # Replace the npm command with the wrapper script path
          # ${SRCROOT} is an Xcode variable that points to the directory containing the .xcodeproj
          # In bash double quotes, \${SRCROOT} becomes ${SRCROOT} which is what we want in the file
          # Need to match the full shellScript line pattern in project.pbxproj
          # Pattern: shellScript = "npm run -- tauri ios xcode-script [args...]";
          # Replace with: shellScript = "${SRCROOT}/build_rust_wrapper.sh [args...]";
          # Use a more specific pattern that captures everything after the npm command
          if grep -q "npm run -- tauri ios xcode-script" "$PROJECT_FILE"; then
            # Use perl for more reliable multiline/pattern matching
            perl -i -pe 's|(shellScript = ")npm run -- tauri ios xcode-script |$1\${SRCROOT}/build_rust_wrapper.sh |g' "$PROJECT_FILE"
            # Fix the FORCE_COLOR issue - remove "0" that appears when FORCE_COLOR is empty
            perl -i -pe 's| --configuration \$\{CONFIGURATION:\?\} 0 \$\{ARCHS:\?\}| --configuration \$\{CONFIGURATION:\?\} \$\{ARCHS:\?\}|g' "$PROJECT_FILE"
            perl -i -pe 's| --configuration \$\{CONFIGURATION:\?\} 0"| --configuration \$\{CONFIGURATION:\?\}"|g' "$PROJECT_FILE"
            echo "Updated build script using perl replacement"
          else
            echo "Note: npm command not found in project file (may have been already replaced)"
            # Still fix the FORCE_COLOR/arch issue even if wrapper is already set
            perl -i -pe 's| --configuration \$\{CONFIGURATION:\?\} 0 \$\{ARCHS:\?\}| --configuration \$\{CONFIGURATION:\?\} \$\{ARCHS:\?\}|g' "$PROJECT_FILE" || true
          fi
          
          # Fix: Remove libapp.a from Resources build phase (it should only be in Frameworks)
          # App Store validation fails if libapp.a is copied into the app bundle
          if grep -q "libapp.a in Resources" "$PROJECT_FILE"; then
            echo "Removing libapp.a from Resources phase (should only be in Frameworks)..."
            perl -i -pe 's|^\s*D85AEC8F3A553813F4C8FFE9 /\* libapp\.a in Resources \*/.*\n||g' "$PROJECT_FILE"
            perl -i -pe 's|,\s*D85AEC8F3A553813F4C8FFE9 /\* libapp\.a in Resources \*/||g' "$PROJECT_FILE"
            echo "✓ Removed libapp.a from Resources phase"
          fi
          
          echo "Updated build script to use wrapper at: \${SRCROOT}/build_rust_wrapper.sh"
          
          # Verify the replacement worked
          if grep -q "\${SRCROOT}/build_rust_wrapper.sh" "$PROJECT_FILE"; then
            echo "✓ Verified: Project file contains wrapper script path"
            # Show the actual line to verify it looks correct
            echo "Script line in project file:"
            grep "\${SRCROOT}/build_rust_wrapper.sh" "$PROJECT_FILE" | head -1
          else
            echo "⚠ Warning: Project file replacement might have failed"
            echo "=== project.pbxproj shellScript lines ==="
            grep -n "shellScript" "$PROJECT_FILE" | sed -n '1,20p' || true
            grep -n "tauri ios xcode-script" "$PROJECT_FILE" || true
            echo "=== end project.pbxproj lines ==="
            echo "Checking for remaining npm command references:"
            if grep -n "tauri ios xcode-script" "$PROJECT_FILE"; then
              echo "ERROR: npm command still found in project file - sed replacement failed!"
              exit 1
            else
              echo "No npm command found (replacement may have worked with different pattern)"
            fi
          fi
        fi
      
    - name: Build iOS IPA for TestFlight
      timeout-minutes: 12
      env:
        APPSTORE_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}
        APPSTORE_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
        APPSTORE_PRIVATE_KEY: ${{ secrets.APPSTORE_PRIVATE_KEY }}
        PROVISIONING_PROFILE_UUID: ${{ env.PROVISIONING_PROFILE_UUID }}
        DEVELOPMENT_TEAM: ${{ env.DEVELOPMENT_TEAM }}
      run: |
        # Verify frontend assets are ready (Tauri will bundle from dist/ automatically)
        # tauri.conf.json specifies frontendDist: "../dist" so Tauri knows where to find assets
        if [ -d "dist" ] && [ -n "$(ls -A dist 2>/dev/null)" ]; then
          echo "✓ Frontend assets ready in dist/ ($(ls -1 dist/ | wc -l | tr -d ' ') items)"
          ls -lh dist/ | head -5
          echo "Tauri will bundle these assets from dist/ per frontendDist config"
        else
          echo "ERROR: dist/ directory is empty or doesn't exist - frontend build failed"
          ls -la dist/ || echo "dist/ does not exist"
          exit 1
        fi
        
        # Re-apply wrapper script modification to project file
        # Tauri might regenerate the project file, so we need to ensure our changes are in place
        XCODE_PROJECT="src-tauri/gen/apple/circuit-assistant-mobile-companion.xcodeproj"
        PROJECT_FILE="$XCODE_PROJECT/project.pbxproj"
        WRAPPER_SCRIPT="src-tauri/gen/apple/build_rust_wrapper.sh"
        
        if [ -f "$PROJECT_FILE" ] && [ -f "$WRAPPER_SCRIPT" ]; then
          echo "Re-applying wrapper script modification to project file..."
          if grep -q "npm run -- tauri ios xcode-script" "$PROJECT_FILE"; then
            perl -i -pe 's|(shellScript = ")npm run -- tauri ios xcode-script |$1\${SRCROOT}/build_rust_wrapper.sh |g' "$PROJECT_FILE"
            echo "✓ Re-applied wrapper script to project file"
          else
            echo "✓ Project file already uses wrapper script"
          fi
          
          # Verify one more time
          if grep -q "\${SRCROOT}/build_rust_wrapper.sh" "$PROJECT_FILE"; then
            echo "✓ Final verification: Project file contains wrapper script"
          else
            echo "⚠ WARNING: Project file does not contain wrapper script path!"
            echo "This may cause the build to fail. Showing project file line:"
            grep -n "shellScript" "$PROJECT_FILE" | head -1 || echo "No shellScript found"
          fi
        else
          echo "⚠ Warning: Project file or wrapper script not found, skipping re-application"
        fi
        
        # Note: We no longer pre-build Rust libraries here
        # Tauri build will run during Xcode archive phase (via wrapper script)
        # This ensures iOS FFI exports (_start_app symbol) are generated correctly
        # The wrapper script sets CI environment variables to prevent dev server issues
        # Caching handles Rust dependencies and iOS project files for faster rebuilds
        
        # Create ExportOptions.plist for App Store distribution
        mkdir -p build
        cat > build/ExportOptions.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>method</key>
            <string>app-store</string>
            <key>destination</key>
            <string>export</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>signingCertificate</key>
            <string>Apple Distribution</string>
            <key>provisioningProfiles</key>
            <dict>
                <key>org.circuitassistant.camc</key>
                <string>$PROVISIONING_PROFILE_UUID</string>
            </dict>
        </dict>
        </plist>
        EOF
        
        # Find the generated Xcode project
        XCODE_PROJECT="src-tauri/gen/apple/circuit-assistant-mobile-companion.xcodeproj"
        SCHEME="circuit-assistant-mobile-companion_iOS"
        ARCHIVE_PATH="$PWD/build/ios.xcarchive"
        EXPORT_PATH="$PWD/build/ios-export"
        
        # The Rust library is already built above and copied to the expected location
        # Skip the build step and go straight to archive, which will build if needed
        # The archive command will build the app, but we've pre-built the Rust code
        echo "Pre-built Rust library is ready, proceeding to archive step..."
        
        # Archive the app - this will build everything including the Rust code
        # But since we've pre-built the Rust library, the build script should find it
        echo "Archiving iOS app (this will build if needed)..."
        
        # Set environment variables to prevent Tauri dev server connection
        export TAURI_SKIP_DEV_SERVER=1
        export TAURI_DEV_HOST="127.0.0.1:1"
        export CI=true
        export RELEASE_BUILD=true
        
        # Print diagnostic info before archiving
        echo "=== Diagnostics ==="
        echo "PROVISIONING_PROFILE_UUID=$PROVISIONING_PROFILE_UUID"
        echo "DEVELOPMENT_TEAM=$DEVELOPMENT_TEAM"
        echo "CODE_SIGN_IDENTITY='Apple Distribution'"
        echo "Provisioning profiles installed:"
        ls -la ~/Library/MobileDevice/Provisioning\ Profiles || true
        echo "Provisioning profile content preview:"
        for f in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
          echo "---- $f ----"
          /usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<< "$(security cms -D -i "$f")" || true
          /usr/libexec/PlistBuddy -c 'Print :TeamIdentifier' /dev/stdin <<< "$(security cms -D -i "$f")" || true
        done
        echo "Certificates (codesign identities):"
        security find-identity -v -p codesigning || true
        echo "xcodebuild -list:"
        xcodebuild -list -project "$XCODE_PROJECT" || true
        echo "xcodebuild -showBuildSettings for scheme:"
        xcodebuild -showBuildSettings -project "$XCODE_PROJECT" -scheme "$SCHEME" -configuration Release || true
        echo "=== End diagnostics ==="
        
        # Check for wrapper script log files before starting build
        echo "=== Checking for existing wrapper script logs ==="
        ls -la /tmp/tauri-wrapper-*.log 2>/dev/null || echo "No existing wrapper logs found"
        
        # Ensure keychain is unlocked before archive/codesign operations
        # This prevents codesign from hanging if keychain auto-locked
        echo "=== Ensuring keychain is unlocked for codesigning ==="
        security unlock-keychain -p "" ~/Library/Keychains/build.keychain
        security set-keychain-settings -t 600 -l ~/Library/Keychains/build.keychain
        echo "✓ Keychain verified unlocked"
        
        # Update build number and ensure export compliance key just before archiving
        # (Tauri/Xcode may regenerate Info.plist earlier, so we do this at the last moment)
        # Format: YYYYMMDD.RUN_NUMBER (e.g., 20251107.15) - consistent with local builds
        BUILD_NUMBER="$(date +%Y%m%d).${{ github.run_number }}"
        INFO_PLIST="src-tauri/gen/apple/circuit-assistant-mobile-companion_iOS/Info.plist"
        if [ -f "$INFO_PLIST" ]; then
          echo "Updating build number to: $BUILD_NUMBER"
          # Use -0 to slurp file and /s to make . match newlines
          perl -i -0pe "s|(<key>CFBundleVersion</key>[^<]*<string>)[^<]*(</string>)|\${1}$BUILD_NUMBER\${2}|s" "$INFO_PLIST"
          echo "✓ CFBundleVersion updated to: $BUILD_NUMBER"
          
          # Ensure export compliance key is present (fixes "Missing Compliance" in TestFlight)
          if ! grep -q "ITSAppUsesNonExemptEncryption" "$INFO_PLIST"; then
            echo "Adding export compliance key to Info.plist (was missing)..."
            perl -i -0pe 's|</dict>\s*</plist>|\t<key>ITSAppUsesNonExemptEncryption</key>\n\t<false/>\n</dict>\n</plist>|' "$INFO_PLIST"
            echo "✓ Export compliance key added"
          else
            echo "✓ Export compliance key confirmed present"
          fi
          
          # Display final version info
          echo "Final version information for archive:"
          grep -A1 "CFBundleVersion\|ITSAppUsesNonExemptEncryption" "$INFO_PLIST" | head -6
        fi
        echo ""
        
        # Save full unfiltered output for debugging
        FULL_LOG="/tmp/xcodebuild-archive-full.log"
        set -o pipefail
        # Use tee without xcbeautify to avoid hiding errors
        if ! xcodebuild archive \
          -project "$XCODE_PROJECT" \
          -scheme "$SCHEME" \
          -configuration Release \
          -destination "generic/platform=iOS" \
          -archivePath "$ARCHIVE_PATH" \
          CODE_SIGN_STYLE=Manual \
          CODE_SIGN_IDENTITY="Apple Distribution" \
          PROVISIONING_PROFILE_SPECIFIER="$PROVISIONING_PROFILE_UUID" \
          DEVELOPMENT_TEAM="$DEVELOPMENT_TEAM" \
          CONFIGURATION=release \
          2>&1 | tee "$FULL_LOG"; then
          echo "========================================="
          echo "Archive failed. Full unfiltered output:"
          echo "========================================="
          sed -n '1,400p' "$FULL_LOG" || true
          echo "========================================="
          echo "Checking for wrapper script log files:"
          ls -la /tmp/tauri-wrapper-*.log 2>/dev/null || echo "No wrapper logs found"
          echo "========================================="
          echo "Latest wrapper script log (if exists):"
          LATEST_WRAPPER_LOG=$(ls -t /tmp/tauri-wrapper*.log 2>/dev/null | head -1)
          if [ -n "$LATEST_WRAPPER_LOG" ]; then
            echo "File: $LATEST_WRAPPER_LOG"
            cat "$LATEST_WRAPPER_LOG" || echo "Failed to read log file"
          else
            echo "No wrapper log file found"
          fi
          echo "========================================="
          echo "Checking for specific errors in full log:"
          grep -E "(Error|error|panic|failed|Abort|codesign|Provisioning)" "$FULL_LOG" | tail -40 || echo "No error patterns found"
          exit 1
        fi
        
        # Optionally beautify the log for viewing (non-blocking)
        echo "Archive succeeded. Beautified output:"
        cat "$FULL_LOG" | xcbeautify || true
        
        # Verify archive was created
        if [ ! -d "$ARCHIVE_PATH" ]; then
          echo "Error: Archive was not created at $ARCHIVE_PATH"
          exit 1
        fi
        echo "Archive created successfully at $ARCHIVE_PATH"
        
        # Export IPA for App Store
        xcodebuild -exportArchive \
          -archivePath "$ARCHIVE_PATH" \
          -exportPath "$EXPORT_PATH" \
          -exportOptionsPlist build/ExportOptions.plist \
          | xcbeautify || cat
        
        # Find the IPA
        IPA_FILE=$(find "$EXPORT_PATH" -name "*.ipa" | head -n 1)
        if [ -z "$IPA_FILE" ]; then
          echo "Error: IPA file not found in $EXPORT_PATH"
          ls -la "$EXPORT_PATH" || echo "Export path does not exist"
          exit 1
        fi
        echo "IPA_PATH=$IPA_FILE" >> $GITHUB_ENV
        echo "Built IPA: $IPA_FILE"
      
    - name: Upload to TestFlight
      timeout-minutes: 5
      env:
        APPSTORE_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}
        APPSTORE_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
        APPSTORE_PRIVATE_KEY: ${{ secrets.APPSTORE_PRIVATE_KEY }}
      run: |
        bundle exec fastlane ios testflight ipa:"$IPA_PATH"
      
    - name: Upload iOS build artifact
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: camc-ios-${{ github.ref_name }}
        path: |
          src-tauri/gen/ios/build/
          ${{ env.IPA_PATH }}
          build/ios-export/*.ipa
          build/*.ipa